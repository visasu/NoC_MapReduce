//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /afs/asu.edu/users/v/s/r/vsriva10/EEE591/HW2/starter-02/primitives/MapReduceMapper.vp
//  Source template: MapReduceMapper
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

//MapReduceMapper.vp
//

localparam dest_bits = $clog2(`NUM_USER_RECV_PORTS);
localparam vc_bits = (`NUM_VCS > 1) ? $clog2(`NUM_VCS) : 1;
localparam flit_port_width = 2 /*valid and tail bits*/+ `FLIT_DATA_WIDTH + dest_bits + vc_bits;

module MapReduceMapper_unq1 (
	input logic enable, 
	input logic [31:0] task_id,
	input logic [5*`DATA_WIDTH-1:0] key,
	input logic [`DATA_WIDTH-1:0] value,//m>n
	input logic clk,
	input logic rstn,
	input logic clear,
	input logic tail,
    input logic [vc_bits:0] get_credit, // [vc_bits-1+1:0]
    output logic en_get_credit,
    output logic [vc_bits:0] put_credits_mapper, // [vc_bits-1+1:0]
    output logic en_put_credits_mapper,
	output logic finish, 
	output logic read_request,
	output logic write_request,
	output logic [5*`DATA_WIDTH-1:0] int_key,
	output logic [31:0] int_value,
	output logic [31:0] read_addr,
	output logic [31:0] write_addr,
	output logic [flit_port_width-1:0] flit_out_mapper
);


//	logic [31:0] index;
	logic [31:0] counter;
	logic [3:0] index;
//	logic [31:0] addr;
	logic [5*`DATA_WIDTH-1:0] word;
    logic [2:0] num_credits;
	logic done;

    assign en_get_credit = 1'b1;

//Clk can be added just index increment has to be added too and remove for loop
	always @(posedge clk or posedge clear or negedge rstn)
	begin
		if(clear || ~rstn)
		begin
			done=0;
			counter=0;
			index=0;
			finish=0;
			word={40{8'h20}};
            put_credits_mapper=2'b00;
            en_put_credits_mapper=1'b1;
            num_credits <= 3'b111;
		end
        else if (enable == 0 )
        begin
            counter = 0;
            flit_out_mapper = '0;
            put_credits_mapper=2'b00; // assert when accepting input, goes back to noc arb
            en_put_credits_mapper=1'b1; // assert when accepting input, goes back to noc arb
        end
        else
        begin
            if (get_credit[vc_bits])
            begin
                num_credits <= num_credits+1; // reducer is sending a credit back
            end
		    if((enable==1)&&(tail!=1)&&(done==0))
		    begin
                put_credits_mapper=2'b10; // assert when accepting input, goes back to noc arb
                en_put_credits_mapper=1'b1; // assert when accepting input, goes back to noc arb
		    	finish=0;
                counter=0;
		    	//word[8*(index+1)-1:8*index]=value[7:0];
                if (index>0)
                begin
                    word = word << `DATA_WIDTH; // shift left by 64, new data is LSBs
                end
//		    	word[`DATA_WIDTH*index +: `DATA_WIDTH-1]=value;
		    	word[`DATA_WIDTH-1:0]=value;
		    	index=index+1;
                flit_out_mapper = '0;
		    end
		    else if((enable==1)&&(tail==1)&&(done==0))
		    begin
                put_credits_mapper=2'b10; // assert when accepting input, goes back to noc arb
                en_put_credits_mapper=1'b1; // assert when accepting input, goes back to noc arb
//		    	word[8*(index+1)-1:8*index]=value[7:0];
//		    	word[`DATA_WIDTH*index +: `DATA_WIDTH-1]=value;
//		    	word = {word[4*`DATA_WIDTH-1:0], value};
//		    	done=1;
		    	if(key=={word[4*`DATA_WIDTH-1:0], value})
                begin
		    		counter=counter+1;
		    	    finish=1;
                    flit_out_mapper = {1'b1, 1'b1, `REDUCER_PORT, 1'b0, 64'b1};
                    num_credits = num_credits-1;
                end
                else
                begin
                    finish=0;
                    flit_out_mapper = '0;
                end
		    	int_key={word[4*`DATA_WIDTH-1:0], value};//bitwidth should be same
		    	word={40{8'h20}};
//		    	int_key=key;//bitwidth should be same
		    	int_value=counter;//bw(int_value > counter)
		    	write_addr=task_id;
		    	write_request=1;
//		    	done=0;
		    end
        end
//		else if((enable==1)&&(done==1))
//		begin
//			if(word==key)
//            begin
//				counter=counter+1;
//            end
//			int_key=key;//bitwidth should be same
//			int_value=counter;//bw(int_value > counter)
//			write_addr=task_id;
//			write_request=1;
//			finish=1;
//			done=0;
//		end
	end
			
/*
		if(enable)
		begin
			counter=0;
			int_key=key;//bitwidth should be same
			int_value=counter;//bw(int_value > counter)
			write_addr=task_id;
			write_request=1;
			finish=1;
		end

	end	
*/

endmodule: MapReduceMapper_unq1

